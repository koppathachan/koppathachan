---
title: "Memoization"
date: 2020-09-20T23:50:30+05:30
draft: false
categories: ["Programming"]
tags: ["functionalprogramming", "js", "javascript", "memoization", "memoize", "recursion"]
---

Memoization is an *optimization technique* used in functional
programming to speed up execution by storing the results of resource
expensive function calls. When the function is called again with the
same input the result is fetched from the cache and returned. This is
possible in functional programming languages because of the use of
*pure functions* as discussed in this [[https://akhilsasidharan.in/posts/functional-programming/][post]]. Purely functional
languages such as Haskell has inbuilt support for memoization. In
javascript, using a mutable map (object, map, caches) we can implement
a memoization.

Memoization is especially useful in recursive functions. Writing code
the functional way makes my code expressive and testable. However, as
I will demonstrate now, in javascript (and most other impure
functional languages) recursion is horrendously slow. Recursion is
essential to functional programming.

Let's look at the *fibonacci series*. The mathematical formula of
which is,

F_{n} = F_{n-1} + F_{n-2}, where F_{0} = 0, F_{1} = 1

or

F_{n} = F_{n-1} + F_{n-2}, when n > 1, and

F_{n} = n, when n <= 1

Looking at this equation one can see why recursive function appeals
here. Look at the analogous js code.
#+Name: EgFibRec
#+BEGIN_SRC js
  const fib = (n) => n > 1 ? fib(n - 1) + fib(n - 2) : n;
#+END_SRC
To calculate the fibonacci of 40 the above function took more than a
second. Beyond fibonacci of 50 the output depends on what video I am
playing on my laptop. The non recursive but super fast code looks like
this.
#+Name: EgFib
#+BEGIN_SRC js
  const uglyFib = (n) => {
      let a = 0, b = 1, c, i;
      if (n == 0) return a;
      for (i = 2; i <= n; i++) {
	  c = a + b;  // We violate immutability rule here
	  a = b;      // and here
	  b = c;      // and here
      }
      return b;
  };
#+END_SRC
It doesn't look anything like its mathematical representation. I
wished it had the charming good looks of its recursive counterpart to
go with its dashing performance. The wish was granted; we
have memoization.

But first let me show you what happens while calculating the fibonacci
value of 5. fib(5).

#+Name: Fib5Tree
#+BEGIN_SRC ditaa
fib(5)
|
+--fib(4)
|  |
|  +--fib(3)-------------------------------1
|  |  |                                    |
|  |  +--fib(2)-----------------1          |    
|  |  |  |                      |          |
|  |  |  *--fib(1)              |          |
|  |  |  |                      |          |
|  |  |  *--fib(0)              |          |
|  |  |                         |          |
|  |  +--fib(1)                 |          |
|  |                            |          |
|  +--fib(2)--------------------2          |
|     |                         |          |  
|     *--fib(1)                 |          | 
|     |                         |          |
|     *--fib(0)                 |          |
+--fib(3)-----------------------|----------2
|  |                            |
|  +--fib(2)--------------------3
|  |  |
|  |  *--fib(1)
|  |  |
|  |  *--fib(1)
|  |
|  +--fib(1)
#+END_SRC
From the above tree we can see that fib(3) is called 2 times, fib(2)
is called 3 times, fib(1) 6 times and fib(0) 2 times. Memoization is
how we avoid these repeated calls by saving the result the first time
fib(n) is called. When the result is returned its value is cached in
an object with the key as the functions input (n in this case). This
can be reused by subsequent calls to the function with the same input.

Let's look at a basic implementation of memoization.
#+Name: EgMemoizedFib
#+BEGIN_SRC js
  const fibonacci = (n, memo = {}) {   // provide a default object as
				       // cache.
    if (memo[n]) { return memo[n]; }   // looking in the cache.
    if (n <= 1) { return 1; }
    memo[n] = fibonacci(n - 1, memo) + // save the result and pass the
	      fibonacci(n - 2, memo);  // cache object.
    return memo[n];                    // return the result
  }
#+END_SRC

The above implementation not only caches the result of fibonacci(5),
but also intermediate results of fibonacci(4), fibonacci(3) and all
the rest of them.

Some npm modules like fast-memoize and memoize provide generic
implementations to memoize any function like this.
#+Name: EgMemoizedFib
#+BEGIN_SRC js
  const memoize = require('fast-memoize')
  const fn = function (one, two, three) { /* ... */ }
  const memoized = memoize(fn)
  memoized('foo', 3, 'bar')
  memoized('foo', 3, 'bar') // Cache hit
#+END_SRC
But they do not cache intermediate results like we saw above in the
custom implementation. While I do like custom implementations over a
generic solution for this I attempted a generic solution that caches
intermediate values. 

#+Name: EgMemoizedFib
#+BEGIN_SRC js
  export const memoize = (func, cache = Object.create(null)) => {

  // here we do some magic to sanitize body and arguments recieved from
  // the func.toString() call. Then we return a new function as shown
  // below.

    return new Function('cache',
  `
  return function ${func.name} (${args}) {
    let result = cache[JSON.stringify([${args}])]
    if (result) { return result; }
    result = ${body}
    cache[JSON.stringify([${args}])] = result;
    return result;
  }
  `)(cache);
  };
#+END_SRC
Not an elegant solution admittedly, but it does the job, given the
limitations of javascript. You can explore the full code at
https://github.com/sasidakh/memoizer.

I tested this implementation where the fibonacci of 40 was calculated
and it was only 4 times slower (the first time it was called) than its
non recursive counter part as opposed to being nearly 40000 times
slower.
| Without recursion            | : | : | x               |
| With recursion               | : | : | ~ 39000x slower |
| Memoized recursion           | : | : | ~4x slower      |
| Memoized recursion ran twice | : | : | ~42x faster     |

*Wo-hoo! My code is faster thanks to memoization*

You can run the tests on the [[https://github.com/sasidakh/memoizer][repo]] to understand it better.
